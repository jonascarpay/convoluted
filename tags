!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_NAME	hasktags
ArbUnboxed	./test/VolumeSpec.hs	/^newtype ArbUnboxed = ArbUnboxed (U.Vector Double) deriving (Eq, Show)$/;"	nt	line:9	language:Haskell
ArbUnboxed	./test/VolumeSpec.hs	/^newtype ArbUnboxed = ArbUnboxed (U.Vector Double) deriving (Eq, Show)$/;"	cons	line:9	language:Haskell
Core	./src/Core.hs	/^module Core where$/;"	m	line:9	language:Haskell
CreatableNetwork	./src/Network.hs	/^class CreatableNetwork (i :: Size) (xs :: [*]) (o :: Nat) where$/;"	c	line:43	language:Haskell
GCons	./src/Network.hs	/^  GCons :: Updatable x => Gradient x -> Gradients xs -> Gradients (x ': xs)$/;"	c_a	line:41	language:Haskell
GNil	./src/Network.hs	/^  GNil  :: Updatable x => Gradient x -> Gradients '[x]$/;"	c_a	line:40	language:Haskell
Gradient	./src/Network.hs	/^  type Gradient l :: *$/;"	t	line:27	language:Haskell
Gradients	./src/Network.hs	/^data Gradients :: [*] -> * where$/;"	d_gadt	line:39	language:Haskell
Layer	./src/Network.hs	/^class Updatable l => Layer l (i :: Size) (o :: Size) where$/;"	c	line:31	language:Haskell
Layers	./src/Layers.hs	/^module Layers where$/;"	m	line:13	language:Haskell
LearningParameters	./src/Network.hs	/^data LearningParameters = LearningParameters$/;"	d	line:20	language:Haskell
LearningParameters	./src/Network.hs	/^data LearningParameters = LearningParameters$/;"	d	line:20	language:Haskell
Mass	./src/Core.hs	/^  type Mass a :: Nat$/;"	t	line:22	language:Haskell
Measure	./src/Core.hs	/^class Measure (a :: Size) where$/;"	c	line:20	language:Haskell
Measure	./src/Core.hs	/^class Measure (a :: Size) where$/;"	c	line:20	language:Haskell
MultiSoftMax	./src/Layers.hs	/^data MultiSoftMax (cs :: [Nat]) = MultiSoftMax$/;"	d	line:23	language:Haskell
MultiSoftMax	./src/Layers.hs	/^data MultiSoftMax (cs :: [Nat]) = MultiSoftMax$/;"	d	line:23	language:Haskell
NCons	./src/Network.hs	/^  NCons :: Layer x i o      => !x -> !(Network o xs no) -> Network i (x ': xs) no$/;"	c_a	line:37	language:Haskell
NNil	./src/Network.hs	/^  NNil  :: Layer x i (S1 o) => !x                       -> Network i '[x]      o$/;"	c_a	line:36	language:Haskell
Network	./src/Network.hs	/^data Network (i :: Size) (ls :: [*]) (o :: Nat) where$/;"	d_gadt	line:35	language:Haskell
RepaShape	./src/Core.hs	/^  type RepaShape a$/;"	t	line:21	language:Haskell
S1	./src/Core.hs	/^data Size = S1 Nat$/;"	d	line:15	language:Haskell
S2	./src/Core.hs	/^          | S2 Nat Nat$/;"	cons	line:16	language:Haskell
S3	./src/Core.hs	/^          | S3 Nat Nat Nat$/;"	cons	line:17	language:Haskell
S4	./src/Core.hs	/^          | S4 Nat Nat Nat Nat$/;"	cons	line:18	language:Haskell
SArray	./src/Volume.hs	/^newtype SArray r (s :: Size) = SArray (Array r (RepaShape s)      Double)$/;"	nt	line:28	language:Haskell
SArray	./src/Volume.hs	/^newtype SArray r (s :: Size) = SArray (Array r (RepaShape s)      Double)$/;"	cons	line:28	language:Haskell
SBatch	./src/Volume.hs	/^newtype SBatch r (s :: Size) = SBatch (Array r (RepaShape s:.Int) Double)$/;"	nt	line:29	language:Haskell
SBatch	./src/Volume.hs	/^newtype SBatch r (s :: Size) = SBatch (Array r (RepaShape s:.Int) Double)$/;"	cons	line:29	language:Haskell
Size	./src/Core.hs	/^data Size = S1 Nat$/;"	d	line:15	language:Haskell
Updatable	./src/Network.hs	/^class Updatable l where$/;"	c	line:26	language:Haskell
Volume	./src/Volume.hs	/^module Volume $/;"	m	line:10	language:Haskell
VolumeSpec	./test/VolumeSpec.hs	/^module VolumeSpec where$/;"	m	line:3	language:Haskell
a	./src/Core.hs	/^  type Mass a :: Nat$/;"	ft	line:22	language:Haskell
applyDelta	./src/Network.hs	/^  applyDelta      :: Monad m => LearningParameters -> l -> Gradient l -> m (l, Gradient l)$/;"	ft	line:28	language:Haskell
approx	./test/VolumeSpec.hs	/^approx :: Double -> Double -> Double -> Bool$/;"	ft	line:29	language:Haskell
approx	./test/VolumeSpec.hs	/^approx x y epsilon = abs (x - y) < epsilon$/;"	fi	line:30	language:Haskell
approx3	./test/VolumeSpec.hs	/^approx3 :: Double -> Double -> Bool$/;"	ft	line:32	language:Haskell
approx3	./test/VolumeSpec.hs	/^x `approx3` y = approx x y 1e-3$/;"	fi	line:33	language:Haskell
createRandom	./src/Network.hs	/^  createRandom    :: MonadRandom m => m l$/;"	ft	line:29	language:Haskell
i	./src/Network.hs	/^data Network (i :: Size) (ls :: [*]) (o :: Nat) where$/;"	c_a	line:35	language:Haskell
i	./src/Network.hs	/^data Network (i :: Size) (ls :: [*]) (o :: Nat) where$/;"	ft	line:35	language:Haskell
instance	./src/Core.hs	/^instance KnownNat w => Measure (S1 w) where$/;"	fi	line:25	language:Haskell
instance	./src/Layers.hs	/^instance Updatable (MultiSoftMax cs) where$/;"	fi	line:25	language:Haskell
instance	./test/VolumeSpec.hs	/^instance Arbitrary ArbUnboxed where$/;"	fi	line:11	language:Haskell
l	./src/Network.hs	/^  type Gradient l :: *$/;"	ft	line:27	language:Haskell
l	./src/Network.hs	/^  runBackwards :: Monad m => l -> SBatch U i -> SBatch U o -> m (Gradient l, SBatch U o)$/;"	c	line:33	language:Haskell
learningMomentum	./src/Network.hs	/^  , learningMomentum       :: !Double$/;"	c_a	line:22	language:Haskell
learningRate	./src/Network.hs	/^  { learningRate           :: !Double$/;"	c_a	line:21	language:Haskell
learningRegularization	./src/Network.hs	/^  , learningRegularization :: !Double$/;"	c_a	line:23	language:Haskell
ls	./src/Network.hs	/^data Network (i :: Size) (ls :: [*]) (o :: Nat) where$/;"	c_a	line:35	language:Haskell
m	./src/Network.hs	/^  createRandom    :: MonadRandom m => m l$/;"	c	line:29	language:Haskell
m	./src/Network.hs	/^  randomNetwork :: MonadRandom m => m (Network i xs o)$/;"	c	line:44	language:Haskell
main	./Setup.hs	/^main = defaultMain$/;"	fi	line:2	language:Haskell
main	./test/Spec.hs	/^main :: IO ()$/;"	ft	line:3	language:Haskell
main	./test/Spec.hs	/^main = do _ <- VS.runTests$/;"	fi	line:4	language:Haskell
multiSoftMax	./src/Volume.hs	/^multiSoftMax :: [Int] -> U.Vector Double -> U.Vector Double$/;"	ft	line:38	language:Haskell
multiSoftMax	./src/Volume.hs	/^multiSoftMax !ls !xs = U.concat $ sms (cycle ls) xs$/;"	fi	line:39	language:Haskell
o	./src/Network.hs	/^data Network (i :: Size) (ls :: [*]) (o :: Nat) where$/;"	c_a	line:35	language:Haskell
prop_multiSoftMax_length_invariant	./test/VolumeSpec.hs	/^prop_multiSoftMax_length_invariant (ArbUnboxed xs) =$/;"	fi	line:25	language:Haskell
prop_multiSoftMax_single	./test/VolumeSpec.hs	/^prop_multiSoftMax_single           (ArbUnboxed xs) =$/;"	fi	line:23	language:Haskell
prop_softMax_length_invariant	./test/VolumeSpec.hs	/^prop_softMax_length_invariant (ArbUnboxed xs) = U.length xs == U.length (softMax xs)$/;"	fi	line:19	language:Haskell
prop_softMax_sum_one	./test/VolumeSpec.hs	/^prop_softMax_sum_one          (ArbUnboxed xs) = U.sum (softMax xs) `approx3` 1$/;"	fi	line:17	language:Haskell
randomNetwork	./src/Network.hs	/^  randomNetwork :: MonadRandom m => m (Network i xs o)$/;"	ft	line:44	language:Haskell
runBackwards	./src/Network.hs	/^  runBackwards :: Monad m => l -> SBatch U i -> SBatch U o -> m (Gradient l, SBatch U o)$/;"	ft	line:33	language:Haskell
runForward	./src/Network.hs	/^  runForward   :: Monad m => l -> SBatch U i -> m (SBatch U o)$/;"	ft	line:32	language:Haskell
runTests	./test/VolumeSpec.hs	/^runTests = $quickCheckAll$/;"	fi	line:36	language:Haskell
sExtent	./src/Core.hs	/^  sExtent :: p a -> RepaShape a$/;"	ft	line:23	language:Haskell
sFromFunction	./src/Volume.hs	/^sFromFunction = undefined$/;"	fi	line:46	language:Haskell
softMax	./src/Volume.hs	/^softMax :: U.Vector Double -> U.Vector Double$/;"	ft	line:31	language:Haskell
softMax	./src/Volume.hs	/^softMax !xs = U.map (\/expSum) exps$/;"	fi	line:32	language:Haskell
